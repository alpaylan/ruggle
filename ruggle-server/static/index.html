<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ruggle</title>
  <style>
    :root {
      --bg: #0b0e14;
      --bg2: #11151c;
      --fg: #e6e1cf;
      --muted: #9da9b1;
      --accent: #82aaff;
      --accent2: #c3e88d;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    header {
      padding: 16px 20px;
      background: var(--bg2);
      border-bottom: 1px solid #1f2430;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.5px;
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 160px 140px 140px 120px;
      gap: 10px;
      align-items: center;
    }

    .controls label {
      font-size: 12px;
      color: var(--muted);
    }

    .controls input[type="text"],
    .controls select,
    .controls input[type="number"] {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      background: #0f131a;
      color: var(--fg);
    }

    .controls button {
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      background: var(--accent);
      color: #0b0e14;
      font-weight: 700;
      cursor: pointer;
    }

    .controls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .hint {
      margin: 8px 0 16px;
      color: var(--muted);
      font-size: 12px;
    }

    .results {
      margin-top: 16px;
      display: grid;
      gap: 12px;
    }

    .card {
      padding: 12px 14px;
      border: 1px solid #222836;
      background: #0f131a;
      border-radius: 10px;
    }

    .card .name {
      font-weight: 700;
      color: var(--accent2);
    }

    .card .path {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    .card a {
      color: var(--accent);
      text-decoration: none;
    }

    /* Function card split layout */
    .fn-card {
      display: flex;
      gap: 14px;
      align-items: flex-start;
    }

    .fn-main {
      flex: 1 1 auto;
      min-width: 0;
    }

    .fn-sim {
      flex: 0 0 380px;
      text-align: right;
      color: var(--muted);
      resize: horizontal;
      overflow: auto;
      min-width: 260px;
    }

    @media (max-width: 900px) {
      .fn-card {
        flex-direction: column;
      }

      .fn-sim {
        text-align: left;
        flex: 0 0 auto;
      }
    }

    .fn-actions {
      margin-top: 6px;
    }

    .btn-link {
      background: transparent;
      color: var(--accent);
      border: none;
      padding: 0;
      cursor: pointer;
      font: inherit;
    }

    /* Logs rendering */
    .logs {
      max-height: 60vh;
      min-height: 160px;
      overflow: auto;
      padding: 8px;
      border: 1px solid #222836;
      background: #0a0e15;
      border-radius: 8px;
      white-space: pre;
      overflow-x: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      line-height: 1.4;
      color: var(--fg);
      resize: vertical;
    }

    .logs .log-line {
      border-bottom: 1px solid #1f2430;
      padding: 2px 0;
    }

    .logs .log-line:last-child {
      border-bottom: 0;
    }

    /* Log badges */
    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 10px;
      margin-right: 8px;
      line-height: 1;
    }

    .badge-trace {
      background: #16203a;
      color: #c3dafe;
      border: 1px solid #223563;
    }

    .badge-debug {
      background: #1a2837;
      color: #b3e5fc;
      border: 1px solid #27445b;
    }

    .badge-info {
      background: #123524;
      color: #b9f6ca;
      border: 1px solid #205c3d;
    }

    .badge-warn {
      background: #3a2d12;
      color: #ffe082;
      border: 1px solid #5f4a1a;
    }

    .badge-error {
      background: #3a1616;
      color: #ff8a80;
      border: 1px solid #5f2222;
    }

    .log-msg {
      display: inline-block;
      margin: 0;
      white-space: pre;
    }

    .log-meta {
      display: block;
      font-size: 11px;
      color: #8aa0b8;
      margin-top: 2px;
    }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }

    .modal-backdrop.show {
      display: flex;
    }

    .modal-box {
      background: var(--bg2);
      border: 1px solid #222836;
      border-radius: 10px;
      width: min(92vw, 1200px);
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid #222836;
      background: #0f131a;
    }

    .modal-title {
      font-weight: 700;
    }

    .close-btn {
      background: transparent;
      border: none;
      color: var(--fg);
      font-size: 18px;
      cursor: pointer;
    }

    /* Graph modal */
    .graph-box {
      width: min(96vw, 1200px);
      max-height: 90vh;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    .graph-header {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid #222836;
      background: #0f131a;
    }

    .graph-body {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: 12px;
      padding: 12px;
      overflow: auto;
    }

    .tree {
      background: #0f131a;
      border: 1px solid #222836;
      border-radius: 8px;
      padding: 8px;
      overflow: auto;
    }

    .tree ul {
      list-style: none;
      padding-left: 16px;
      margin: 0;
    }

    .tree li {
      margin: 2px 0;
    }

    .tree .toggle {
      cursor: pointer;
      color: var(--accent);
    }

    .details {
      background: #0f131a;
      border: 1px solid #222836;
      border-radius: 8px;
      padding: 8px;
      overflow: auto;
    }

    .row {
      display: contents;
    }

    .sr-only {
      position: absolute;
      left: -10000px;
    }
  </style>
</head>

<body>
  <header>
    <h1>Ruggle</h1>
  </header>
  <main>
    <div class="controls">
      <div>
        <label for="query">Query</label>
        <input id="query" type="text" placeholder="e.g. fn (Option<Result<T, E>>) -> Result<Option<T>, E>" />
      </div>
      <div>
        <label for="scope">Scope</label>
        <select id="scope"></select>
      </div>
      <div>
        <label for="limit">Limit</label>
        <input id="limit" type="number" min="1" max="200" value="30" />
      </div>
      <div>
        <label for="threshold">Threshold</label>
        <input id="threshold" type="number" step="0.05" min="0" max="1" value="0.4" />
      </div>
      <div>
        <label class="sr-only" for="run">Search</label>
        <button id="run">Search</button>
      </div>
      <div>
        <label class="sr-only" for="openGraph">Graph</label>
        <button id="openGraph">Graph</button>
      </div>
    </div>
    <div class="hint">Scopes are provided by <code>/scopes</code>. Results come from <code>/search</code>.</div>
    <div id="functions" class="results"></div>
    <div id="results" class="results"></div>
  </main>
  <div id="logs-modal" class="modal-backdrop" aria-hidden="true">
    <div class="modal-box">
      <div class="modal-header">
        <div class="modal-title">Compare logs</div>
        <button id="logsClose" class="close-btn" aria-label="Close">×</button>
      </div>
      <div id="logsContent" class="logs"></div>
    </div>
  </div>
  <div id="graph-modal" class="modal-backdrop" aria-hidden="true">
    <div class="modal-box graph-box">
      <div class="graph-header">
        <div class="modal-title">Graph Explorer</div>
        <span style="flex:1 1 auto"></span>
        <label for="graphCrate">Crate</label>
        <select id="graphCrate"></select>
        <button id="graphClose" class="close-btn" aria-label="Close">×</button>
      </div>
      <div class="graph-body">
        <div class="tree">
          <ul id="graphTree"></ul>
        </div>
        <div class="details" id="graphDetails">Select a node</div>
      </div>
    </div>
  </div>
  <script>
    const scopeEl = document.getElementById('scope');
    const queryEl = document.getElementById('query');
    const limitEl = document.getElementById('limit');
    const thresholdEl = document.getElementById('threshold');
    const runBtn = document.getElementById('run');
    const openGraphBtn = document.getElementById('openGraph');
    const resultsEl = document.getElementById('results');
    const functionsEl = document.getElementById('functions');
    const logsModalEl = document.getElementById('logs-modal');
    const logsCloseBtn = document.getElementById('logsClose');
    const logsContentEl = document.getElementById('logsContent');
    const graphModalEl = document.getElementById('graph-modal');
    const graphCloseBtn = document.getElementById('graphClose');
    const graphCrateSel = document.getElementById('graphCrate');
    const graphTreeEl = document.getElementById('graphTree');
    const graphDetailsEl = document.getElementById('graphDetails');
    let currentController = null;

    function debounce(fn, wait) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    function openLogsModal() {
      logsModalEl.classList.add('show');
      logsModalEl.setAttribute('aria-hidden', 'false');
    }
    function closeLogsModal() {
      logsModalEl.classList.remove('show');
      logsModalEl.setAttribute('aria-hidden', 'true');
    }
    logsCloseBtn.addEventListener('click', closeLogsModal);
    logsModalEl.addEventListener('click', (e) => { if (e.target === logsModalEl) closeLogsModal(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeLogsModal(); });
    function openGraphModal() { graphModalEl.classList.add('show'); graphModalEl.setAttribute('aria-hidden', 'false'); }
    function closeGraphModal() { graphModalEl.classList.remove('show'); graphModalEl.setAttribute('aria-hidden', 'true'); }
    graphCloseBtn.addEventListener('click', closeGraphModal);
    graphModalEl.addEventListener('click', (e) => { if (e.target === graphModalEl) closeGraphModal(); });
    openGraphBtn.addEventListener('click', async () => {
      openGraphModal();
      // populate crates in selector
      graphCrateSel.innerHTML = '';
      try {
        const metas = await fetch('/index').then(r => r.json());
        for (const m of metas) {
          const opt = document.createElement('option');
          opt.value = `${m.name}:${m.version}`;
          opt.textContent = `${m.name}:${m.version}`;
          graphCrateSel.appendChild(opt);
        }
      } catch { }
      if (graphCrateSel.value) loadGraph(graphCrateSel.value);
    });
    graphCrateSel.addEventListener('change', () => { if (graphCrateSel.value) loadGraph(graphCrateSel.value); });

    async function loadGraph(crateKey) {
      try {
        const params = new URLSearchParams();
        params.set('crate', crateKey);
        const data = await fetch('/debug/parents?' + params.toString()).then(r => r.json());
        renderGraph(data);
      } catch (e) {
        graphTreeEl.innerHTML = '<li>Failed to load graph</li>';
      }
    }

    function buildAdj(edges) {
      const childrenOf = new Map();
      for (const e of edges) {
        if (!childrenOf.has(e.from)) childrenOf.set(e.from, []);
        childrenOf.get(e.from).push(e.to);
      }
      return childrenOf;
    }
    function indexNodes(nodes) {
      const m = new Map();
      for (const n of nodes) m.set(n.id, n);
      return m;
    }
    function roots(nodes, edges) {
      const childSet = new Set(edges.map(e => e.to));
      const parentSet = new Set(edges.map(e => e.from));
      const res = [];
      for (const n of nodes) if (parentSet.has(n.id) && !childSet.has(n.id)) res.push(n.id);
      // If no clear roots, fall back to any modules
      if (res.length === 0) for (const n of nodes) if (n.kind === 'module') res.push(n.id);
      return Array.from(new Set(res));
    }
    function renderGraph(graph) {
      const nodeById = indexNodes(graph.nodes);
      const kids = buildAdj(graph.edges);
      graphTreeEl.innerHTML = '';
      const rootIds = roots(graph.nodes, graph.edges);
      for (const rid of rootIds) {
        const li = renderNode(rid, nodeById, kids);
        graphTreeEl.appendChild(li);
      }
    }
    function renderNode(id, nodeById, kids) {
      const n = nodeById.get(id);
      const li = document.createElement('li');
      const hasChildren = Array.isArray(kids.get(id)) && kids.get(id).length > 0;
      const title = document.createElement('span');
      title.className = 'toggle';
      title.textContent = `${n?.name || '<unnamed>'} (${n?.kind || 'item'})`;
      title.addEventListener('click', async () => {
        graphDetailsEl.innerHTML = '';
        const hdr = document.createElement('div');
        hdr.className = 'name';
        hdr.textContent = n?.name || '<unnamed>';
        const meta = document.createElement('div');
        meta.className = 'path';
        meta.textContent = `id: ${n.id} • kind: ${n.kind}`;
        graphDetailsEl.appendChild(hdr);
        graphDetailsEl.appendChild(meta);
        // docs link
        try {
          const p = new URLSearchParams();
          p.set('scope', `crate:${graphCrateSel.value}`);
          p.set('id', String(n.id));
          const info = await fetch('/debug/doc?' + p.toString()).then(r => r.json());
          const linkDiv = document.createElement('div');
          const a = document.createElement('a');
          a.href = info.link; a.target = '_blank'; a.rel = 'noreferrer noopener'; a.textContent = 'Open docs';
          linkDiv.appendChild(a);
          graphDetailsEl.appendChild(linkDiv);
        } catch { }
      });
      li.appendChild(title);
      if (hasChildren) {
        const ul = document.createElement('ul');
        for (const cid of kids.get(id)) ul.appendChild(renderNode(cid, nodeById, kids));
        li.appendChild(ul);
      }
      return li;
    }

    function insertBreaksInBraces(s) {
      if (!s) return '';
      let out = String(s);
      // 1) Break before nested cmp_ spans like ":cmp_sig" or ":cmp_fn".
      out = out.replace(/:cmp_[A-Za-z0-9_]+/g, (m) => '\n' + m);
      // 2) For any " key=..." style, break at the whitespace before the key.
      // Replace the preceding space/tab with a newline while keeping key=value intact.
      out = out.replace(/[\t ]([^\s=]+)=/g, (_m, key) => `\n  ${key}=`);
      return out;
    }

    function extractMetaSegments(s) {
      // Parse segments shaped like ": <target::path>: <file/path.rs>:<line>:"
      // They may appear before the actual message and may repeat.
      let text = String(s || '');
      const metas = [];
      // Work from the end to avoid index shifts
      for (; ;) {
        const dbl = text.lastIndexOf('::');
        if (dbl === -1) break;
        const pre = text.lastIndexOf(':', dbl - 1);
        if (pre === -1) break;
        const post = text.indexOf(':', dbl + 2);
        if (post === -1) break;
        const target = text.slice(pre + 1, post).trim();
        const fileSep = text.indexOf(':', post + 1);
        if (fileSep === -1) break;
        const endSep = text.indexOf(':', fileSep + 1);
        if (endSep === -1) break;
        const file = text.slice(post + 1, fileSep).trim();
        const line = text.slice(fileSep + 1, endSep).trim();
        if (!file || !target) break;
        metas.unshift({ target, file, line });
        text = (text.slice(0, pre) + '\n' + text.slice(endSep + 1)).replace(/\s{2,}/g, ' ').trim();
      }
      return { text, metas };
    }

    function renderLogs(text) {
      logsContentEl.innerHTML = '';
      const lines = String(text || '').split('\n');
      for (const raw of lines) {
        const line = raw || ' ';
        const m = line.match(/^(TRACE|DEBUG|INFO|WARN|ERROR)\s*(.*)$/);
        const lvl = m ? m[1] : 'LOG';
        let rest = m ? m[2] : line;
        const metaParsed = extractMetaSegments(rest);
        rest = metaParsed.text;
        const formatted = insertBreaksInBraces(rest);
        const row = document.createElement('div');
        row.className = 'log-line';
        const badge = document.createElement('span');
        badge.className = 'badge ' + 'badge-' + lvl.toLowerCase();
        badge.textContent = lvl;
        const msg = document.createElement('pre');
        msg.className = 'log-msg';
        msg.textContent = formatted;
        row.appendChild(badge);
        row.appendChild(msg);
        if (metaParsed.metas.length) {
          for (const entry of metaParsed.metas) {
            const meta = document.createElement('span');
            meta.className = 'log-meta';
            const pieces = [];
            if (entry.target) pieces.push(entry.target);
            if (entry.file) pieces.push(`${entry.file}${entry.line ? `:${entry.line}` : ''}`);
            meta.textContent = pieces.join(' • ');
            row.appendChild(meta);
          }
        }
        logsContentEl.appendChild(row);
      }
    }

    async function loadScopes() {
      scopeEl.innerHTML = '';
      try {
        const res = await fetch('/scopes');
        const scopes = await res.json();
        scopes.sort();
        for (const s of scopes) {
          const opt = document.createElement('option');
          opt.value = s;
          opt.textContent = s;
          scopeEl.appendChild(opt);
        }
        // Select a sane default if present
        const libstd = Array.from(scopeEl.options).find(o => o.value === 'set:libstd');
        if (libstd) scopeEl.value = 'set:libstd';
      } catch (e) {
        console.error(e);
      }
    }

    function renderResults(hits) {
      resultsEl.innerHTML = '';
      if (!hits || hits.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'card';
        empty.textContent = 'No results';
        resultsEl.appendChild(empty);
        return;
      }
      for (const h of hits) {
        const card = document.createElement('div');
        card.className = 'card';
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = h.name;
        const path = document.createElement('div');
        path.className = 'path';
        path.textContent = (h.path || []).join('::');
        const link = document.createElement('div');
        const a = document.createElement('a');
        a.href = h.link;
        a.target = '_blank';
        a.rel = 'noreferrer noopener';
        a.textContent = 'Open docs';
        link.appendChild(a);
        card.appendChild(name);
        card.appendChild(path);
        card.appendChild(link);
        resultsEl.appendChild(card);
      }
    }

    function getEnum(obj) {
      if (!obj || typeof obj !== 'object') return { kind: undefined, value: undefined };
      const keys = Object.keys(obj);
      if (keys.length === 0) return { kind: undefined, value: undefined };
      const kind = keys[0];
      return { kind, value: obj[kind] };
    }

    function formatType(ty) {
      const { kind, value } = getEnum(ty);
      switch (kind) {
        case 'primitive':
          return value;
        case 'generic':
          return value;
        case 'resolved_path':
          return value?.path || '<path>';
        case 'tuple':
          return `(${(value || []).map(formatType).join(', ')})`;
        case 'borrowed_ref': {
          const lt = value?.lifetime ? `'${value.lifetime} ` : '';
          const mut = value?.is_mutable ? 'mut ' : '';
          return `&${lt}${mut}${formatType(value?.type)}`;
        }
        case 'raw_pointer':
          return `*${value?.is_mutable ? 'mut' : 'const'} ${formatType(value?.type)}`;
        case 'array':
          return `[${formatType(value?.type)}; ${value?.len ?? '?'}]`;
        case 'slice':
          return `[${formatType(value?.type)}]`;
        case 'function_pointer': {
          const args = (value?.sig?.inputs || []).map(([n, t]) => `${n}: ${formatType(t)}`);
          const ret = value?.sig?.output ? ` -> ${formatType(value.sig.output)}` : '';
          return `fn(${args.join(', ')})${ret}`;
        }
        case 'qualified_path':
          return `<qualified path>::${value?.name ?? ''}`;
        case 'dyn_trait':
          return 'dyn <trait>';
        case 'impl_trait':
          return 'impl <trait bounds>';
        case 'infer':
          return '_';
        case 'pat':
          return '<pattern type>';
        default:
          return kind || '<unknown type>';
      }
    }

    function formatGenericBound(b) {
      const { kind, value } = getEnum(b);
      switch (kind) {
        case 'trait_bound': {
          const tr = value?.trait?.path || '<trait>';
          const mod = value?.modifier === 'maybe' ? '?' : (value?.modifier === 'maybe_const' ? ' + const' : '');
          return `${tr}${mod}`;
        }
        case 'outlives':
          return value;
        case 'use':
          return `use<${(value || []).join(', ')}>`;
        default:
          return kind || '<bound>';
      }
    }

    function formatGenericParam(p) {
      const { kind, value } = getEnum(p?.kind);
      if (!kind) return p?.name || '';
      if (kind === 'lifetime') {
        return `'$${p?.name || ''}`.replace("'$", "'");
      }
      if (kind === 'type') {
        const bounds = (value?.bounds || []).map(formatGenericBound).join(' + ');
        return bounds ? `${p?.name}: ${bounds}` : (p?.name || 'T');
      }
      if (kind === 'const') {
        return `const ${p?.name}: ${formatType(value?.type)}`;
      }
      return p?.name || '';
    }

    function formatWherePredicate(w) {
      const { kind, value } = getEnum(w);
      if (kind === 'bound_predicate') {
        const typeStr = formatType(value?.type);
        const boundsStr = (value?.bounds || []).map(formatGenericBound).join(' + ');
        const gens = (value?.generic_params || []).map(g => g?.name).filter(Boolean);
        const forStr = gens.length ? `for<${gens.join(', ')}> ` : '';
        return `${forStr}${typeStr}: ${boundsStr}`;
      }
      if (kind === 'lifetime_predicate') {
        return `${value?.lifetime}: ${(value?.outlives || []).join(' + ')}`;
      }
      if (kind === 'eq_predicate') {
        const lhs = formatType(value?.lhs);
        const rhsEnum = getEnum(value?.rhs);
        const rhs = rhsEnum.kind === 'type' ? formatType(rhsEnum.value) : (rhsEnum.kind === 'constant' ? (rhsEnum.value?.expr || '<const>') : '<term>');
        return `${lhs} = ${rhs}`;
      }
      return '';
    }

    function formatAbi(abi) {
      const { kind, value } = getEnum(abi);
      if (!kind || kind === 'rust') return '';
      if (kind === 'other') return `extern "${value}" `;
      const name = kind.replace(/_/g, '').replace(/^(\w)/, (m) => m.toUpperCase());
      const unwind = value?.unwind ? '-unwind' : '';
      return `extern "${name}${unwind}" `;
    }

    function formatVisibility(v) {
      const { kind, value } = getEnum(v);
      if (!kind) return '';
      if (kind === 'public') return 'pub';
      if (kind === 'crate') return 'pub(crate)';
      if (kind === 'default') return '';
      if (kind === 'restricted') return `pub(in ${value?.path || '...'})`;
      return kind;
    }

    function formatFunctionSignature(fn) {
      const quals = [fn?.header?.is_const ? 'const' : '', fn?.header?.is_unsafe ? 'unsafe' : '', fn?.header?.is_async ? 'async' : '']
        .filter(Boolean)
        .join(' ');
      const genParams = (fn?.generics?.params || []).map(formatGenericParam).filter(Boolean);
      const genStr = genParams.length ? `<${genParams.join(', ')}>` : '';
      const args = (fn?.sig?.inputs || []).map(([n, ty]) => `${n}: ${formatType(ty)}`);
      const ret = fn?.sig?.output ? ` -> ${formatType(fn.sig.output)}` : '';
      const wherePreds = (fn?.generics?.where_predicates || []).map(formatWherePredicate).filter(Boolean);
      const whereStr = wherePreds.length ? ` where ${wherePreds.join(', ')}` : '';
      const abiStr = formatAbi(fn?.header?.abi);
      return `${abiStr}${quals ? quals + ' ' : ''}fn${genStr}(${args.join(', ')})${ret}${whereStr}`;
    }

    function formatSimilarity(sim) {
      console.log(sim);
      if (!sim) return '';
      const parts = Array.isArray(sim.parts) ? sim.parts.map(p => {
        if (p.discrete) return p.discrete;
        if (typeof p.continuous === 'number') return p.continuous.toFixed(2);
        return '?';
      }) : [];
      const score = (typeof sim.score === 'number') ? sim.score.toFixed(3) : '?';
      return `similarity: score ${score} [${parts.join(', ')}]`;
    }

    function getItemId(it) {
      if (!it || it.id == null) return null;
      if (Array.isArray(it.id) && it.id.length > 1) return it.id[1];
      return it.id;
    }

    function renderFunctions(items, simById = null, parsedQuery = null, docById = null) {
      functionsEl.innerHTML = '';
      if (parsedQuery) {
        const qhdr = document.createElement('div');
        qhdr.className = 'card';
        const title = document.createElement('div');
        title.className = 'name';
        title.textContent = 'Parsed Query';
        const pre = document.createElement('pre');
        pre.textContent = JSON.stringify(parsedQuery, null, 2);
        qhdr.appendChild(title);
        qhdr.appendChild(pre);
        functionsEl.appendChild(qhdr);
      }
      if (!items || items.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'card';
        empty.textContent = 'No functions in scope';
        functionsEl.appendChild(empty);
        return;
      }
      for (const it of items) {
        const card = document.createElement('div');
        card.className = 'card fn-card';

        const main = document.createElement('div');
        main.className = 'fn-main';

        const right = document.createElement('div');
        right.className = 'fn-sim';

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = it.name || '(unnamed)';

        const { kind, value } = getEnum(it.inner || {});
        const vis = formatVisibility(it.visibility);
        const sigLine = document.createElement('div');
        sigLine.className = 'path';
        if (kind === 'function') {
          sigLine.textContent = `${vis ? vis + ' ' : ''}${formatFunctionSignature(value)}`;
        } else {
          sigLine.textContent = `[${kind || 'item'}]`;
        }

        const spanLine = document.createElement('div'); // path / location
        spanLine.className = 'path';
        if (it.span && it.span.filename) {
          const begin = it.span.begin || [];
          const end = it.span.end || [];
          spanLine.textContent = `${it.span.filename} (${begin.join(':')} - ${end.join(':')})`;
        } else {
          spanLine.textContent = 'span: <unknown>';
        }

        // Always-visible core info
        main.appendChild(name);
        main.appendChild(sigLine);
        main.appendChild(spanLine);

        // Hidden extra details by default
        const detailsWrap = document.createElement('div');
        detailsWrap.style.display = 'none';

        const docs = document.createElement('div');
        docs.className = 'path';
        if (it.docs) {
          const text = String(it.docs);
          const brief = text.length > 200 ? text.slice(0, 200) + '…' : text;
          docs.textContent = brief;
        } else {
          docs.textContent = 'docs: <none>';
        }

        const metaId = document.createElement('div');
        metaId.className = 'path';
        metaId.textContent = `id: ${getItemId(it) ?? '?'}  •  crate_id: ${it.crate_id}`;

        const bodyLine = document.createElement('div');
        bodyLine.className = 'path';
        if (kind === 'function') {
          bodyLine.textContent = `body: ${value?.has_body ? 'yes' : 'no'}`;
        }

        const attrsLine = document.createElement('div');
        attrsLine.className = 'path';
        if (Array.isArray(it.attrs) && it.attrs.length) {
          const names = it.attrs.map(a => Object.keys(a)[0]).join(', ');
          attrsLine.textContent = `attributes: ${names}`;
        } else {
          attrsLine.textContent = 'attributes: <none>';
        }

        const deprecLine = document.createElement('div');
        deprecLine.className = 'path';
        if (it.deprecation) {
          const since = it.deprecation.since ? `since ${it.deprecation.since}` : '';
          const note = it.deprecation.note ? `: ${it.deprecation.note}` : '';
          deprecLine.textContent = `deprecated ${since}${note}`.trim();
        } else {
          deprecLine.textContent = 'deprecated: no';
        }

        const linksLine = document.createElement('div');
        linksLine.className = 'path';
        linksLine.textContent = `intra links: ${it.links ? Object.keys(it.links).length : 0}`;

        detailsWrap.appendChild(metaId);
        detailsWrap.appendChild(bodyLine);
        detailsWrap.appendChild(attrsLine);
        detailsWrap.appendChild(deprecLine);
        detailsWrap.appendChild(linksLine);
        detailsWrap.appendChild(docs);

        const actions = document.createElement('div');
        actions.className = 'fn-actions';
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'btn-link';
        toggleBtn.textContent = 'Show details';
        toggleBtn.addEventListener('click', () => {
          const shown = detailsWrap.style.display !== 'none';
          detailsWrap.style.display = shown ? 'none' : 'block';
          toggleBtn.textContent = shown ? 'Show details' : 'Hide details';
        });
        actions.appendChild(toggleBtn);

        main.appendChild(actions);
        main.appendChild(detailsWrap);

        // Right side: similarity (when query present)
        const qStr = queryEl.value.trim();
        if (qStr.length > 0) {
          const simLine = document.createElement('div');
          simLine.className = 'path';
          const sid = getItemId(it);
          const sim = sid != null && simById ? simById.get(String(sid)) : null;
          simLine.textContent = sim ? formatSimilarity(sim) : 'similarity: <error>';
          right.appendChild(simLine);

          // Logs button
          const logsBtn = document.createElement('button');
          logsBtn.className = 'btn-link';
          logsBtn.textContent = 'View compare logs';
          logsBtn.addEventListener('click', async () => {
            try {
              logsBtn.disabled = true;
              logsBtn.textContent = 'Fetching logs…';
              openLogsModal();
              renderLogs('Loading…');
              const p = new URLSearchParams();
              p.set('scope', scopeEl.value || '');
              p.set('query', qStr);
              p.set('id', String(sid));
              const r = await fetch('/debug/compare_logs?' + p.toString());
              const data = await r.json();
              renderLogs(data.logs || '');
              logsBtn.textContent = 'View compare logs';
            } catch (e) {
              logsBtn.textContent = 'Logs error';
            } finally {
              logsBtn.disabled = false;
            }
          });
          right.appendChild(logsBtn);
        }

        // Docs link (if available)
        const sid2 = getItemId(it);
        if (sid2 != null && docById && docById.get(String(sid2))) {
          const info = docById.get(String(sid2));
          const linkWrap = document.createElement('div');
          const a = document.createElement('a');
          a.href = info.link;
          a.target = '_blank';
          a.rel = 'noreferrer noopener';
          a.textContent = 'Open docs';
          linkWrap.appendChild(a);
          right.appendChild(linkWrap);
        }

        card.appendChild(main);
        if (right.childNodes.length) card.appendChild(right);
        functionsEl.appendChild(card);
      }
    }

    async function updateFunctions() {
      // Get all functions in the selected scope from /debug
      try {
        const scope = scopeEl.value;
        if (!scope) return;
        const params = new URLSearchParams();
        params.set('scope', scope);
        const res = await fetch('/debug/functions?' + params.toString());
        let functions = await res.json();
        const q = queryEl.value.trim();
        // Prefetch doc links for all items
        const docEntries = await Promise.allSettled(functions.map(async (it) => {
          const id = getItemId(it);
          if (id == null) throw new Error('no id');
          const p = new URLSearchParams();
          p.set('scope', scope);
          p.set('id', String(id));
          const r = await fetch('/debug/doc?' + p.toString());
          const info = await r.json();
          return [String(id), info];
        }));
        const docById = new Map(docEntries
          .filter(e => e.status === 'fulfilled')
          .map(e => e.value));
        if (q.length > 0) {
          // fetch parsed query for display
          let parsed = null;
          try {
            const qres = await fetch('/debug/query?query=' + encodeURIComponent(q));
            parsed = await qres.json();
          } catch { }
          // prefetch similarities, then sort by score asc
          const entries = await Promise.allSettled(functions.map(async (it) => {
            const id = getItemId(it);
            if (id == null) throw new Error('no id');
            const p = new URLSearchParams();
            p.set('scope', scope);
            p.set('query', q);
            p.set('id', String(id));
            const r = await fetch('/debug/similarity?' + p.toString());
            const sim = await r.json();
            return [String(id), sim];
          }));
          const simById = new Map(entries
            .filter(e => e.status === 'fulfilled')
            .map(e => e.value));
          functions.sort((a, b) => {
            const sa = simById.get(String(getItemId(a)))?.score;
            const sb = simById.get(String(getItemId(b)))?.score;
            if (typeof sa === 'number' && typeof sb === 'number') return sa - sb;
            if (typeof sa === 'number') return -1;
            if (typeof sb === 'number') return 1;
            return 0;
          });
          renderFunctions(functions, simById, parsed, docById);
          return;
        }
        renderFunctions(functions, null, null, docById);
      } catch (e) {
        console.error(e);
      }
    }
    async function runSearch() {
      const query = queryEl.value.trim();
      const scope = scopeEl.value;
      const limit = parseInt(limitEl.value, 10) || 30;
      const threshold = parseFloat(thresholdEl.value);
      if (!scope) return;
      if (query.length < 2) { // avoid excessive queries
        resultsEl.innerHTML = '';
        return;
      }
      runBtn.disabled = true;
      try {
        // cancel previous in-flight request
        if (currentController) currentController.abort();
        currentController = new AbortController();
        const params = new URLSearchParams();
        params.set('scope', scope);
        params.set('query', query);
        params.set('limit', String(limit));
        params.set('threshold', String(isFinite(threshold) ? threshold : 0.4));
        // show a lightweight loading hint
        resultsEl.innerHTML = '<div class="card">Searching…</div>';
        const res = await fetch('/search?' + params.toString(), { signal: currentController.signal });
        const hits = await res.json();
        renderResults(hits);
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error(e);
        }
      } finally {
        runBtn.disabled = false;
      }
    }

    const debouncedSearch = debounce(runSearch, 300);
    const debouncedUpdateFunctions = debounce(updateFunctions, 300);
    runBtn.addEventListener('click', runSearch);
    queryEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') { runSearch(); updateFunctions(); } });
    queryEl.addEventListener('input', (e) => { debouncedSearch(); debouncedUpdateFunctions(); });
    scopeEl.addEventListener('change', () => {
      updateFunctions();
      if (queryEl.value.trim().length >= 2) runSearch();
    });

    (async () => {
      await loadScopes();
      await updateFunctions();
    })();
  </script>
</body>

</html>